<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Планирование поставки — FuckBerry</title>
  <link rel="icon" href="/favicon.ico" sizes="any" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css" />
  <link rel="stylesheet" href="/static/styles.css" />
  <style>
    h1 { font-size: 1.7rem; }
    .form-section {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .form-section h5 {
      color: #495057;
      margin-bottom: 15px;
      font-weight: 600;
    }
    button.calendar-day {
    border: none;
    }
    .btn-calculate {
      background: linear-gradient(135deg, #007bff, #0056b3);
      border: none;
      height: 37px;
      padding: 0;
      width: 50%;
      font-weight: 400;
      border-radius: 8px;
      transition: all 0.3s ease;
    }
    .btn-calculate:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
    }
    .result-section {
      background: #fff;
      border: 1px solid #dee2e6;
      border-radius: 8px;
      padding: 20px;
      margin-top: 20px;
      display: none;
    }
    .result-section.show {
      display: block;
    }
    .table-responsive {
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .table th {
      font-weight: 600;
      border-bottom: 2px solid #dee2e6;
    }
    .loading {
      text-align: center;
      padding: 40px;
      color: #6c757d;
    }
    .spinner-border-sm {
      width: 1rem;
      height: 1rem;
    }
    .editable-cell {
      border: 1px solid #ced4da;
      border-radius: 4px;
      transition: all 0.2s ease;
    }
    .editable-cell:focus {
      border-color: #007bff;
      box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
    }
    .editable-cell:hover {
      border-color: #86b7fe;
    }
    .table th {
      font-size: 0.9rem;
      white-space: nowrap;
    }
    .table td {
      vertical-align: middle;
    }
    .text-end {
      text-align: right !important;
    }
    .warehouse-search-item {
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid #f0f0f0;
    }
    .warehouse-search-item:hover {
      background-color: #f8f9fa;
    }
    .warehouse-search-item:last-child {
      border-bottom: none;
    }
    .warehouse-name {
      font-weight: 500;
      color: #333;
    }
    .warehouse-details {
      font-size: 0.85em;
      color: #666;
      margin-top: 2px;
    }
    .warehouse-sorting-center {
      background-color: #e3f2fd;
      border-left: 3px solid #2196f3;
    }
    
    /* Стили для таблицы планирования */
    .planning-table {
      font-size: 13px;
    }
    
    .table-container {
      border: 1px solid #dee2e6;
      border-radius: 0.375rem;
      position: relative;
    }
    
    .totals-row {
      background-color: #e3f2fd !important;
      font-weight: bold;
      border-top: 2px solid #2196f3;
    }
    
    .totals-row td {
      border-top: 2px solid #2196f3;
    }
    
    
    .planning-table th {
      text-align: center;
      vertical-align: middle;
      white-space: nowrap;
      padding: 8px 4px;
      position: sticky;
      top: 0;
      z-index: 100;
      background-color: #212529;
      border-bottom: 2px solid #dee2e6;
    }
    
    .planning-table .totals-row th {
      position: sticky;
      top: 61px; /* Высота первой строки шапки */
      z-index: 99;
      background-color: #e3f2fd !important;
      border-top: 2px solid #2196f3;
      border-bottom: 2px solid #2196f3;
      font-weight: bold;
      text-align: center;
      vertical-align: middle;
      white-space: nowrap;
      padding: 8px 4px;
    }
    
    /* Убираем полосы для строки итогов */
    .planning-table .totals-row {
      background-color: #e3f2fd !important;
    }
    
    .planning-table .totals-row:nth-child(odd) {
      background-color: #e3f2fd !important;
    }
    
    .planning-table .totals-row:nth-child(even) {
      background-color: #e3f2fd !important;
    }
    
    /* Стили для выпадающего календаря */
    .calendar-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      background: white;
      border: 1px solid #dee2e6;
      border-radius: 0.375rem;
      box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
      z-index: 1050;
      margin-top: 0.25rem;
      width: 320px;
      max-width: 90vw;
    }
    
    .calendar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      border-bottom: 1px solid #dee2e6;
      background-color: #f8f9fa;
    }
    
    .calendar-nav {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      transition: background-color 0.15s ease-in-out;
    }
    
    .calendar-nav:hover {
      background-color: #e9ecef;
    }
    
    .calendar-grid {
      padding: 1rem;
    }
    
    .calendar-weekdays {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 0.25rem;
      margin-bottom: 0.5rem;
    }
    
    .calendar-weekday {
      text-align: center;
      font-weight: 600;
      font-size: 0.875rem;
      color: #6c757d;
      padding: 0.5rem 0;
    }
    
    .calendar-days {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 0.25rem;
    }
    
    .calendar-day {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      border-radius: 0.25rem;
      font-size: 0.875rem;
      transition: all 0.15s ease-in-out;
      position: relative;
    }
    
    .calendar-day:hover {
      background-color: #e9ecef;
    }
    
    .calendar-day.other-month {
      color: #adb5bd;
    }
    
    .calendar-day.today {
      background-color: #fff3cd;
      color: #856404;
      font-weight: 600;
    }
    
    .calendar-day.selected-start {
      background-color: #0d6efd;
      color: white;
      font-weight: 600;
    }
    
    .calendar-day.selected-end {
      background-color: #0d6efd;
      color: white;
      font-weight: 600;
    }
    
    .calendar-day.in-range {
      background-color: #e7f1ff;
      color: #0d6efd;
    }
    
    .calendar-day.in-range:not(.selected-start):not(.selected-end) {
      border-radius: 0;
    }
    
    .calendar-day.selected-start.in-range {
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }
    
    .calendar-day.selected-end.in-range {
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }
    
    .calendar-footer {
      display: flex;
      justify-content: space-between;
      padding: 1rem;
      border-top: 1px solid #dee2e6;
      background-color: #f8f9fa;
    }
    
    .calendar-day.weekend {
      color: #dc3545;
    }
    
    .calendar-day.other-month.weekend {
      color: #f5c6cb;
    }
    
    /* Мобильное позиционирование календаря */
    @media (max-width: 768px) {
      .calendar-dropdown.mobile-centered {
        position: fixed !important;
        top: 50% !important;
        left: 50% !important;
        transform: translate(-50%, -50%) !important;
        width: 90vw !important;
        max-width: 400px !important;
        z-index: 1060 !important;
        margin: 0 !important;
        box-shadow: 0 0.5rem 2rem rgba(0, 0, 0, 0.3) !important;
      }
      
      .calendar-dropdown.mobile-centered .calendar-grid {
        max-height: 60vh;
        overflow-y: auto;
      }
    }
    
    .planning-table td {
      vertical-align: middle;
      padding: 6px 4px;
    }
    
    .planning-table .product-name {
      white-space: nowrap;
      overflow: visible;
      text-overflow: unset;
    }
    
    .planning-table .numeric-column {
      text-align: center;
      width: 80px;
    }
    
    .planning-table .barcode-column {
      width: 120px;
      max-width: 120px;
    }
    
    .planning-table .photo-column {
      width: 80px;
      max-width: 80px;
      text-align: center;
    }
    
    .planning-table .product-name-column {
      width: 400px;
      min-width: 400px;
      max-width: none;
    }
    
    .planning-table .editable-cell {
      text-align: center;
      width: 80px;
    }
    
    .planning-table .editable-cell input {
      width: 100%;
      text-align: center;
      border: 1px solid #ddd;
      padding: 2px 4px;
      font-size: 13px;
    }
    
    .planning-table .editable-cell input.highlighted {
      background-color: #5ec34a73 !important;
    }
    
    /* Вертикальные разделители для таблицы */
    .planning-table th,
    .planning-table td {
      border-right: 1px solid #dee2e6;
    }
    
    .planning-table th:last-child,
    .planning-table td:last-child {
      border-right: none;
    }
    
    .planning-table {
      border-collapse: separate;
      border-spacing: 0;
    }
    
    /* Компактные стили для формы планирования */
    .form-text.small {
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }
    
    @media (max-width: 768px) {
      .form-section .row .col-md-2 {
        margin-bottom: 1rem;
      }
      .form-section .row .col-md-4 {
        margin-bottom: 1rem;
      }
    }
    
    /* Стили для кнопки Excel */
    #exportExcelBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    #exportExcelBtn:not(:disabled):hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
    }
  </style>
</head>
<body>
  {% include '_navbar.html' %}

  <div class="container mt-3">
    <div class="d-flex justify-content-between align-items-center mb-4">
      <h1 class="mb-0">Планирование поставки FBW</h1>
    </div>

    {% if error %}
      <div class="alert alert-danger">{{ error }}</div>
    {% endif %}

    <div class="form-section">
      <h5>📊 Параметры планирования</h5>
      <form id="planningForm">
        <div class="row">
          <div class="col-md-2 mb-3">
            <label for="warehouse" class="form-label">
              Склад назначения
              <i class="bi bi-info-circle text-muted ms-1" 
                 data-bs-toggle="tooltip" 
                 data-bs-placement="top" 
                 title="Выберите склад на который планируете отгрузку"
                 style="cursor: help;"></i>
            </label>
            <div class="position-relative">
              <input type="text" class="form-control" id="warehouseSearch" placeholder="Начните печатать для поиска склада..." autocomplete="off">
              <select class="form-select" id="warehouse" name="warehouse" style="display: none;">
                <option value="">Выберите склад</option>
              </select>
              <div id="warehouseDropdown" class="dropdown-menu w-100" style="max-height: 300px; overflow-y: auto; display: none;"></div>
            </div>
          </div>
          <div class="col-md-2 mb-3">
            <label for="salesPeriodRange" class="form-label">
              Период продаж
              <i class="bi bi-info-circle text-muted ms-1" 
                 data-bs-toggle="tooltip" 
                 data-bs-placement="top" 
                 title="Выберите период продаж (Рекомендуем последние 2 месяца)"
                 style="cursor: help;"></i>
            </label>
            <div class="position-relative" style="position: relative !important;">
              <input type="text" class="form-control" id="salesPeriodRange" placeholder="Выберите период продаж" readonly style="cursor: pointer;" />
              <input type="hidden" name="salesPeriodFrom" id="salesPeriodFrom" />
              <input type="hidden" name="salesPeriodTo" id="salesPeriodTo" />
              <span class="position-absolute top-50 end-0 translate-middle-y me-3" style="cursor: pointer;" id="salesPeriodBtn">📅</span>
              <div id="salesPeriodCalendar" class="calendar-dropdown" style="display: none;">
                <div class="calendar-header">
                  <button type="button" class="calendar-nav" id="salesPeriodPrevMonth">‹</button>
                  <span id="salesPeriodCurrentMonthYear">Сентябрь 2025</span>
                  <button type="button" class="calendar-nav" id="salesPeriodNextMonth">›</button>
                </div>
                <div class="calendar-grid" id="salesPeriodCalendarGrid">
                  <div class="calendar-weekdays" id="salesPeriodWeekdays">
                    <!-- Заголовки дней недели будут генерироваться JavaScript -->
                  </div>
                  <div class="calendar-days" id="salesPeriodDays">
                    <!-- Дни календаря будут генерироваться JavaScript -->
                  </div>
                </div>
                <div class="calendar-footer">
                  <button type="button" class="btn btn-sm btn-outline-secondary" id="salesPeriodResetDates">Сбросить</button>
                  <button type="button" class="btn btn-sm btn-primary" id="salesPeriodApplyDates">Применить</button>
                </div>
              </div>
            </div>
          </div>
          <div class="col-md-2 mb-3">
            <label for="planningDays" class="form-label">
              Дней планирования
              <i class="bi bi-info-circle text-muted ms-1" 
                 data-bs-toggle="tooltip" 
                 data-bs-placement="top" 
                 title="Кол-во дней на которое необходим остаток товара (Рекомендуем 60 дней)"
                 style="cursor: help;"></i>
            </label>
            <input type="number" class="form-control" id="planningDays" name="planningDays" 
                   value="30" min="1" max="365" required>
          </div>
          <div class="col-md-2 mb-3">
            <label for="supplyDate" class="form-label">
              Дата поставки
              <i class="bi bi-info-circle text-muted ms-1" 
                 data-bs-toggle="tooltip" 
                 data-bs-placement="top" 
                 title="Укажите предположительную дату поставки на склад, она будет добавлена к количеству дней планирования"
                 style="cursor: help;"></i>
            </label>
            <input type="date" class="form-control" id="supplyDate" name="supplyDate" required>
          </div>
          <div class="col-md-3 mb-3 d-flex align-items-end">
            <button type="submit" class="btn btn-primary btn-calculate w-100">
              <i class="bi bi-calculator me-2"></i>
              Посчитать потребность
            </button>
          </div>
        </div>
      </form>
    </div>

    <div class="result-section" id="resultSection">
      <div class="d-flex justify-content-between align-items-center mb-3">
        <h5 class="mb-0" data-bs-toggle="tooltip" data-bs-placement="top" 
            title="<strong>Формулы расчета:</strong><br>
• <strong>Продаж в день</strong> = Заказано за период ÷ Количество дней периода<br>
• <strong>Необходимый остаток</strong> = Продаж в день × (Дни планирования + Дни до поставки)<br>
• <strong>Оборачиваемость</strong> = Текущий остаток ÷ Продаж в день<br>
• <strong>Поставить на склад</strong> = Необходимый остаток - Текущий остаток - В пути на склад">
          📈 Результат планирования
        </h5>
        <div class="d-flex align-items-center gap-3">
          <div id="productsCount" class="text-muted small" style="display: none;">
            <!-- Количество товаров будет показано здесь -->
          </div>
          <div class="btn-group">
            <button type="button" class="btn btn-outline-secondary btn-sm" id="tableSettingsBtn" title="Настройки таблицы">
              <i class="bi bi-gear"></i>
            </button>
            <button type="button" class="btn btn-success btn-sm" id="exportExcelBtn" disabled>
              <i class="bi bi-file-earmark-excel me-1"></i>
              Сохранить в Excel
            </button>
          </div>
        </div>
      </div>
      <div class="loading" id="loadingDiv">
        <div class="spinner-border text-primary" role="status">
          <span class="visually-hidden">Загрузка...</span>
        </div>
        <div class="mt-2" id="loadingText">Загружаем товары пользователя...</div>
      </div>
      
      <div id="resultsContent" style="display: none;">
        <div class="table-container">
          <table id="resultsTable" class="table table-striped table-hover planning-table">
            <thead class="table-dark">
              <tr>
                <th class="numeric-column" style="width: 50px;">№</th>
                <th class="barcode-column">Баркод</th>
                <th class="photo-column" style="width: 80px;">Фото</th>
                <th class="product-name-column">Наименование</th>
                <th class="numeric-column">
                  Текущий<br>остаток
                  <button type="button" class="btn btn-sm btn-outline-light ms-1 sort-btn" data-column="currentStock" title="Сортировать">
                    <i class="bi bi-arrow-down-up"></i>
                  </button>
                </th>
                <th class="numeric-column">
                  Остаток по<br>всем складам
                  <button type="button" class="btn btn-sm btn-outline-light ms-1 sort-btn" data-column="allStocks" title="Сортировать">
                    <i class="bi bi-arrow-down-up"></i>
                  </button>
                </th>
                <th class="numeric-column">
                  В пути<br>на склад
                  <button type="button" class="btn btn-sm btn-outline-light ms-1 sort-btn" data-column="inTransit" title="Сортировать">
                    <i class="bi bi-arrow-down-up"></i>
                  </button>
                </th>
                <th class="numeric-column">
                  Заказано<br>за период
                  <button type="button" class="btn btn-sm btn-outline-light ms-1 sort-btn" data-column="orderedInPeriod" title="Сортировать">
                    <i class="bi bi-arrow-down-up"></i>
                  </button>
                </th>
                <th class="numeric-column">
                  Продаж<br>в день
                  <button type="button" class="btn btn-sm btn-outline-light ms-1 sort-btn" data-column="salesPerDay" title="Сортировать">
                    <i class="bi bi-arrow-down-up"></i>
                  </button>
                </th>
                <th class="numeric-column">
                  Необходимый<br>остаток
                  <button type="button" class="btn btn-sm btn-outline-light ms-1 sort-btn" data-column="requiredStock" title="Сортировать">
                    <i class="bi bi-arrow-down-up"></i>
                  </button>
                </th>
                <th class="numeric-column">
                  Оборачиваемость
                  <button type="button" class="btn btn-sm btn-outline-light ms-1 sort-btn" data-column="turnover" title="Сортировать">
                    <i class="bi bi-arrow-down-up"></i>
                  </button>
                </th>
                <th class="numeric-column">
                  Поставить<br>на склад
                  <button type="button" class="btn btn-sm btn-outline-light ms-1 sort-btn" data-column="toSupply" title="Сортировать">
                    <i class="bi bi-arrow-down-up"></i>
                  </button>
                </th>
              </tr>
              <!-- Строка с итогами сразу под шапкой -->
              <tr class="table-info totals-row">
                <th class="numeric-column"></th>
                <th class="barcode-column"><strong>ИТОГО:</strong></th>
                <th class="photo-column"></th>
                <th class="product-name-column"></th>
                <th class="numeric-column" id="totalCurrentStock"><strong>0</strong></th>
                <th class="numeric-column" id="totalAllStocks"><strong>0</strong></th>
                <th class="numeric-column" id="totalInTransit"><strong>0</strong></th>
                <th class="numeric-column" id="totalOrdered"><strong>0</strong></th>
                <th class="numeric-column"></th>
                <th class="numeric-column"></th>
                <th class="numeric-column"></th>
                <th class="numeric-column" id="totalToSupply"><strong>0</strong></th>
              </tr>
            </thead>
            <tbody id="resultsTableBody">
              <!-- Результаты будут загружены здесь -->
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <!-- Превью изображения при наведении -->
  <div id="imgPreview" style="display:none; position:fixed; left:50%; top:50%; transform: translate(-50%, -50%); z-index:1060; padding:4px; background:#fff; border:1px solid rgba(0,0,0,.15); box-shadow:0 .5rem 1rem rgba(0,0,0,.15); pointer-events: none;">
    <img id="imgPreviewImg" src="" alt="preview" style="max-width:420px; max-height:560px; display:block;" />
  </div>

  <!-- Модальное окно для уведомления о поставках -->
  <div class="modal fade" id="pendingSuppliesModal" tabindex="-1" aria-labelledby="pendingSuppliesModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="pendingSuppliesModalLabel">
            <i class="bi bi-exclamation-triangle text-warning me-2"></i>
            Обнаружены не принятые поставки
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p class="mb-3">
            На текущий момент есть не принятые поставки на выбранный склад.<br />  
            <strong>Учитывать их при формировании поставки?</strong>
          </p>
          
          <div id="pendingSuppliesList" class="mb-3">
            <!-- Список поставок будет загружен здесь -->
          </div>
          
          <div class="alert alert-info">
            <i class="bi bi-info-circle me-2"></i>
            Если вы выберете "Да", то количество товара из этих поставок будет добавлено в колонку "В пути на склад".
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" id="rejectSuppliesBtn">
            <i class="bi bi-x-circle me-1"></i>
            Нет, не учитывать
          </button>
          <button type="button" class="btn btn-primary" id="acceptSuppliesBtn">
            <i class="bi bi-check-circle me-1"></i>
            Да, учитывать
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Модальное окно настроек таблицы -->
  <div class="modal fade" id="tableSettingsModal" tabindex="-1" aria-labelledby="tableSettingsModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="tableSettingsModalLabel">
            <i class="bi bi-gear me-2"></i>
            Настройки таблицы
          </h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p class="text-muted mb-3">Выберите колонки для отображения в таблице:</p>
          
          <div class="row">
            <div class="col-md-6">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="colNumber" checked>
                <label class="form-check-label" for="colNumber">
                  №
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="colBarcode" checked>
                <label class="form-check-label" for="colBarcode">
                  Баркод
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="colPhoto" checked>
                <label class="form-check-label" for="colPhoto">
                  Фото товара
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="colName" checked>
                <label class="form-check-label" for="colName">
                  Наименование
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="colCurrentStock" checked>
                <label class="form-check-label" for="colCurrentStock">
                  Текущий остаток
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="colAllStocks" checked>
                <label class="form-check-label" for="colAllStocks">
                  Остаток по всем складам
                </label>
              </div>
            </div>
            <div class="col-md-6">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="colInTransit" checked>
                <label class="form-check-label" for="colInTransit">
                  В пути на склад
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="colOrdered" checked>
                <label class="form-check-label" for="colOrdered">
                  Заказано за период
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="colSalesPerDay" checked>
                <label class="form-check-label" for="colSalesPerDay">
                  Продаж в день
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="colRequiredStock" checked>
                <label class="form-check-label" for="colRequiredStock">
                  Необходимый остаток
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="colTurnover" checked>
                <label class="form-check-label" for="colTurnover">
                  Оборачиваемость
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="colToSupply" checked>
                <label class="form-check-label" for="colToSupply">
                  Поставить на склад
                </label>
              </div>
            </div>
          </div>
          
          <div class="mt-3">
            <button type="button" class="btn btn-outline-primary btn-sm" id="selectAllColumns">
              <i class="bi bi-check-square me-1"></i>
              Выбрать все
            </button>
            <button type="button" class="btn btn-outline-secondary btn-sm ms-2" id="deselectAllColumns">
              <i class="bi bi-square me-1"></i>
              Снять все
            </button>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
            <i class="bi bi-x-circle me-1"></i>
            Отмена
          </button>
          <button type="button" class="btn btn-primary" id="applyTableSettings">
            <i class="bi bi-check-circle me-1"></i>
            Применить
          </button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    let allWarehouses = [];
    let filteredWarehouses = [];
    let currentProducts = []; // Для хранения текущих данных таблицы
    let sortDirection = 'desc'; // Направление сортировки: 'asc' или 'desc'
    let pendingSupplies = []; // Непринятые поставки
    let pendingSuppliesModal = null; // Ссылка на модальное окно
    
    // Календарь с выбором диапазона дат для периода продаж
    class SalesPeriodCalendar {
      constructor() {
        this.currentDate = new Date();
        this.selectedStart = null;
        this.selectedEnd = null;
        this.isSelecting = false;
        this.calendar = document.getElementById('salesPeriodCalendar');
        this.input = document.getElementById('salesPeriodRange');
        this.startInput = document.getElementById('salesPeriodFrom');
        this.endInput = document.getElementById('salesPeriodTo');
        this.btn = document.getElementById('salesPeriodBtn');
        this.grid = document.getElementById('salesPeriodCalendarGrid');
        this.weekdays = document.getElementById('salesPeriodWeekdays');
        this.days = document.getElementById('salesPeriodDays');
        this.monthYear = document.getElementById('salesPeriodCurrentMonthYear');
        this.prevBtn = document.getElementById('salesPeriodPrevMonth');
        this.nextBtn = document.getElementById('salesPeriodNextMonth');
        this.resetBtn = document.getElementById('salesPeriodResetDates');
        this.applyBtn = document.getElementById('salesPeriodApplyDates');
        
        this.months = [
          'Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь',
          'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'
        ];
        
        this.weekdayNames = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'];
        
        this.init();
      }
      
      init() {
        if (!this.calendar || !this.input || !this.btn) {
          return;
        }
        
        // Загружаем сохраненные даты
        this.loadSavedDates();
        
        // Обработчики событий
        this.btn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.toggleCalendar();
        });
        this.input.addEventListener('click', (e) => {
          e.stopPropagation();
          this.toggleCalendar();
        });
        this.prevBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.prevMonth();
        });
        this.nextBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.nextMonth();
        });
        this.resetBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.resetSelection();
        });
        this.applyBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.applySelection();
        });
        
        // Закрытие календаря при клике вне его
        document.addEventListener('click', (e) => {
          if (!this.calendar.contains(e.target) && 
              !this.input.contains(e.target) && 
              !this.btn.contains(e.target)) {
            this.hideCalendar();
          }
        });
        
        // Перепозиционирование при изменении размера окна
        window.addEventListener('resize', () => {
          if (this.calendar.style.display === 'block') {
            this.adjustPosition();
          }
        });
        
        this.renderCalendar();
        
        // Предотвращаем закрытие календаря при клике внутри него
        this.calendar.addEventListener('click', (e) => {
          e.stopPropagation();
        });
      }
      
      loadSavedDates() {
        const startValue = this.startInput?.value || '';
        const endValue = this.endInput?.value || '';
        
        if (startValue && endValue) {
          this.selectedStart = new Date(startValue);
          this.selectedEnd = new Date(endValue);
          this.updateInputDisplay();
        } else {
          // Устанавливаем даты по умолчанию
          const today = new Date();
          const thirtyDaysAgo = new Date(today);
          thirtyDaysAgo.setDate(today.getDate() - 30);
          
          this.selectedStart = thirtyDaysAgo;
          this.selectedEnd = today;
          this.updateInputDisplay();
          this.updateHiddenInputs();
        }
      }
      
      toggleCalendar() {
        if (this.calendar.style.display === 'block') {
          this.hideCalendar();
        } else {
          this.showCalendar();
        }
      }
      
      showCalendar() {
        this.calendar.style.display = 'block';
        this.adjustPosition();
        this.renderCalendar();
      }
      
      hideCalendar() {
        this.calendar.style.display = 'none';
      }
      
      adjustPosition() {
        const rect = this.input.getBoundingClientRect();
        const calendar = this.calendar;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        // Проверяем, помещается ли календарь справа
        const spaceRight = viewportWidth - rect.right;
        const spaceLeft = rect.left;
        const spaceBelow = viewportHeight - rect.bottom;
        
        if (spaceRight >= 320) {
          calendar.style.left = '0';
          calendar.style.right = 'auto';
        } else if (spaceLeft >= 320) {
          calendar.style.left = 'auto';
          calendar.style.right = '0';
        } else {
          // Центрируем на мобильных устройствах
          calendar.classList.add('mobile-centered');
        }
        
        // Проверяем вертикальное позиционирование
        if (spaceBelow < 400 && rect.top > 400) {
          calendar.style.top = 'auto';
          calendar.style.bottom = '100%';
          calendar.style.marginTop = '0';
          calendar.style.marginBottom = '0.25rem';
        } else {
          calendar.style.top = '100%';
          calendar.style.bottom = 'auto';
          calendar.style.marginTop = '0.25rem';
          calendar.style.marginBottom = '0';
        }
      }
      
      prevMonth() {
        this.currentDate.setMonth(this.currentDate.getMonth() - 1);
        this.renderCalendar();
      }
      
      nextMonth() {
        this.currentDate.setMonth(this.currentDate.getMonth() + 1);
        this.renderCalendar();
      }
      
      renderCalendar() {
        if (!this.weekdays || !this.days || !this.monthYear) return;
        
        const year = this.currentDate.getFullYear();
        const month = this.currentDate.getMonth();
        
        this.monthYear.textContent = `${this.months[month]} ${year}`;
        
        // Очищаем контейнеры
        this.weekdays.innerHTML = '';
        this.days.innerHTML = '';
        
        // Добавляем заголовки дней недели
        this.weekdayNames.forEach(day => {
          const dayHeader = document.createElement('div');
          dayHeader.className = 'calendar-weekday';
          dayHeader.textContent = day;
          this.weekdays.appendChild(dayHeader);
        });
        
        // Получаем первый день месяца и количество дней
        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        const daysInMonth = lastDay.getDate();
        
        // Находим день недели первого дня (0 = воскресенье, 1 = понедельник, ...)
        let startDay = firstDay.getDay();
        if (startDay === 0) startDay = 7; // Воскресенье = 7
        
        // Добавляем дни предыдущего месяца
        const prevMonth = new Date(year, month - 1, 0);
        const daysInPrevMonth = prevMonth.getDate();
        
        for (let i = startDay - 1; i > 0; i--) {
          const day = daysInPrevMonth - i + 1;
          const dayElement = this.createDayElement(day, true);
          this.days.appendChild(dayElement);
        }
        
        // Добавляем дни текущего месяца
        for (let day = 1; day <= daysInMonth; day++) {
          const dayElement = this.createDayElement(day, false);
          this.days.appendChild(dayElement);
        }
        
        // Добавляем дни следующего месяца для заполнения сетки
        const totalCells = this.days.children.length;
        const remainingCells = 42 - totalCells; // 6 недель * 7 дней
        
        for (let day = 1; day <= remainingCells; day++) {
          const dayElement = this.createDayElement(day, true);
          this.days.appendChild(dayElement);
        }
      }
      
      createDayElement(day, isOtherMonth) {
        const dayElement = document.createElement('button');
        dayElement.className = 'calendar-day';
        dayElement.textContent = day;
        
        if (isOtherMonth) {
          dayElement.classList.add('other-month');
        } else {
          const currentDate = new Date(this.currentDate.getFullYear(), this.currentDate.getMonth(), day);
          this.updateDayClasses(dayElement, currentDate);
          
          // Проверяем, является ли день выходным
          const dayOfWeek = currentDate.getDay();
          if (dayOfWeek === 0 || dayOfWeek === 6) {
            dayElement.classList.add('weekend');
          }
          
          // Проверяем, является ли день сегодняшним
          const today = new Date();
          if (currentDate.toDateString() === today.toDateString()) {
            dayElement.classList.add('today');
          }
          
          dayElement.addEventListener('click', () => {
            this.selectDate(currentDate);
          });
        }
        
        return dayElement;
      }
      
      updateDayClasses(dayElement, date) {
        // Убираем все классы выбора
        dayElement.classList.remove('selected-start', 'selected-end', 'in-range');
        
        if (!this.selectedStart && !this.selectedEnd) return;
        
        const time = date.getTime();
        const startTime = this.selectedStart ? this.selectedStart.getTime() : null;
        const endTime = this.selectedEnd ? this.selectedEnd.getTime() : null;
        
        if (startTime && endTime) {
          // Полный диапазон выбран
          if (time === startTime) {
            dayElement.classList.add('selected-start');
          } else if (time === endTime) {
            dayElement.classList.add('selected-end');
          } else if (time > startTime && time < endTime) {
            dayElement.classList.add('in-range');
          }
        } else if (startTime && time === startTime) {
          // Только начало выбрано
          dayElement.classList.add('selected-start');
        }
      }
      
      selectDate(date) {
        if (!this.selectedStart || (this.selectedStart && this.selectedEnd)) {
          // Начинаем новый выбор
          this.selectedStart = new Date(date);
          this.selectedEnd = null;
          this.isSelecting = true;
        } else if (this.isSelecting) {
          // Завершаем выбор
          if (date < this.selectedStart) {
            this.selectedEnd = this.selectedStart;
            this.selectedStart = new Date(date);
          } else {
            this.selectedEnd = new Date(date);
          }
          this.isSelecting = false;
        }
        
        this.updateInputDisplay();
        this.updateHiddenInputs();
        this.renderCalendar();
      }
      
      updateInputDisplay() {
        if (!this.input) return;
        
        if (this.selectedStart && this.selectedEnd) {
          const startStr = this.formatDate(this.selectedStart);
          const endStr = this.formatDate(this.selectedEnd);
          this.input.value = `${startStr} — ${endStr}`;
        } else if (this.selectedStart) {
          this.input.value = this.formatDate(this.selectedStart);
        } else {
          this.input.value = '';
        }
      }
      
      updateHiddenInputs() {
        if (this.startInput && this.selectedStart) {
          this.startInput.value = this.formatDateForInput(this.selectedStart);
        }
        if (this.endInput && this.selectedEnd) {
          this.endInput.value = this.formatDateForInput(this.selectedEnd);
        }
      }
      
      formatDate(date) {
        return date.toLocaleDateString('ru-RU');
      }
      
      formatDateForInput(date) {
        return date.toISOString().split('T')[0];
      }
      
      resetSelection() {
        this.selectedStart = null;
        this.selectedEnd = null;
        this.isSelecting = false;
        this.updateInputDisplay();
        this.updateHiddenInputs();
        this.renderCalendar();
      }
      
      applySelection() {
        this.hideCalendar();
        this.validateDates();
      }
      
      validateDates() {
        const df = this.startInput?.value || '';
        const dt = this.endInput?.value || '';
        
        let ok = true; 
        let msg = '';
        
        if (df && dt && df > dt) {
          ok = false; 
          msg = 'Дата начала периода должна быть раньше даты окончания';
        }
        if (!df || !dt) {
          ok = false; 
          msg = 'Выберите период продаж';
        }
        
        return ok;
      }
    }
    
    document.addEventListener('DOMContentLoaded', function() {
      // Инициализируем тултипы Bootstrap
      var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
      var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
        return new bootstrap.Tooltip(tooltipTriggerEl, {
          html: true
        });
      });
      
      // Обработчик для кнопки Excel
      document.getElementById('exportExcelBtn').addEventListener('click', function() {
        exportToExcel();
      });
      
      // Обработчики для превью изображений
      const preview = document.getElementById('imgPreview');
      const previewImg = document.getElementById('imgPreviewImg');
      
      document.addEventListener('mouseover', function(e){
        const t = e.target;
        if (t && t.classList && t.classList.contains('product-thumb')){
          const src = t.getAttribute('data-src') || t.getAttribute('src');
          previewImg.src = src;
          preview.style.display = 'block';
        }
      });
      
      document.addEventListener('mouseout', function(e){
        const t = e.target;
        if (t && t.classList && t.classList.contains('product-thumb')){
          preview.style.display = 'none';
          previewImg.src = '';
        }
      });
      
      // Загружаем список складов при загрузке страницы
      loadWarehouses();
      
      // Инициализируем календарь периода продаж
      new SalesPeriodCalendar();
      
      // Инициализируем модальное окно
      pendingSuppliesModal = new bootstrap.Modal(document.getElementById('pendingSuppliesModal'));
      
      // Обработчики для модального окна
      document.getElementById('acceptSuppliesBtn').addEventListener('click', function() {
        acceptPendingSupplies();
        pendingSuppliesModal.hide();
      });
      
      document.getElementById('rejectSuppliesBtn').addEventListener('click', function() {
        console.log('Пользователь отклонил поставки, показываем результаты без них');
        pendingSuppliesModal.hide();
        // Показываем результаты без добавления товаров из поставок
        showResultsWithProducts(currentProducts, window.lastFormData);
      });
      
      // Инициализируем модальное окно настроек таблицы
      const tableSettingsModal = new bootstrap.Modal(document.getElementById('tableSettingsModal'));
      
      // Обработчик для кнопки настроек таблицы
      document.getElementById('tableSettingsBtn').addEventListener('click', function() {
        tableSettingsModal.show();
      });
      
      // Обработчики для кнопок выбора колонок
      document.getElementById('selectAllColumns').addEventListener('click', function() {
        const checkboxes = document.querySelectorAll('#tableSettingsModal input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
          checkbox.checked = true;
        });
      });
      
      document.getElementById('deselectAllColumns').addEventListener('click', function() {
        const checkboxes = document.querySelectorAll('#tableSettingsModal input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
          checkbox.checked = false;
        });
      });
      
      // Обработчик для применения настроек таблицы
      document.getElementById('applyTableSettings').addEventListener('click', function() {
        console.log('Кнопка "Применить" нажата');
        applyTableColumnSettings();
        
        // Убираем фокус с кнопки перед закрытием модального окна
        this.blur();
        
        // Закрываем модальное окно
        tableSettingsModal.hide();
      });
      
      // Обработчик для кнопки "Отмена"
      document.querySelector('#tableSettingsModal .btn-secondary').addEventListener('click', function() {
        console.log('Кнопка "Отмена" нажата');
        this.blur();
      });
      
      // Дата поставки по умолчанию - через 7 дней
      const today = new Date();
      const supplyDate = new Date(today);
      supplyDate.setDate(today.getDate() + 7);
      document.getElementById('supplyDate').value = supplyDate.toISOString().split('T')[0];
      
      // Обработчик формы
      document.getElementById('planningForm').addEventListener('submit', function(e) {
        e.preventDefault();
        
        const formData = new FormData(this);
        const data = Object.fromEntries(formData);
        
        // Добавляем название склада из поля поиска
        data.warehouse_name = document.getElementById('warehouseSearch').value;
        
        // Валидация - ищем выбранный склад в данных
        const warehouseName = document.getElementById('warehouseSearch').value;
        let selectedWarehouse = null;
        
        // Ищем склад по названию в загруженных данных
        if (warehouseName && allWarehouses.length > 0) {
          selectedWarehouse = allWarehouses.find(warehouse => 
            warehouse.name === warehouseName
          );
        }
        
        console.log(`Валидация: warehouseName="${warehouseName}", selectedWarehouse:`, selectedWarehouse);
        
        if (!selectedWarehouse || !warehouseName) {
          if (warehouseName && !selectedWarehouse) {
            alert('Пожалуйста, выберите склад из выпадающего списка, а не вводите текст вручную');
          } else {
            alert('Пожалуйста, выберите склад из списка');
          }
          document.getElementById('warehouseSearch').focus();
          document.getElementById('warehouseSearch').style.borderColor = '#dc3545';
          return;
        } else {
          document.getElementById('warehouseSearch').style.borderColor = '';
        // Обновляем скрытый select с найденным ID
        const hiddenSelect = document.getElementById('warehouse');
        
        // Очищаем существующие опции
        hiddenSelect.innerHTML = '';
        
        // Создаем новую опцию с выбранным складом
        const option = document.createElement('option');
        option.value = selectedWarehouse.id;
        option.textContent = selectedWarehouse.name;
        option.selected = true;
        hiddenSelect.appendChild(option);
        
        console.log(`Обновлен скрытый select: ${selectedWarehouse.id}`);
        console.log(`Скрытый select value после обновления: ${hiddenSelect.value}`);
        }
        if (!data.salesPeriodFrom || !data.salesPeriodTo || !data.planningDays || !data.supplyDate) {
          alert('Пожалуйста, заполните все поля');
          return;
        }
        
        // Проверка дат
        const fromDate = new Date(data.salesPeriodFrom);
        const toDate = new Date(data.salesPeriodTo);
        if (fromDate >= toDate) {
          alert('Дата начала периода должна быть раньше даты окончания');
          return;
        }
        
        // Показываем результат и загружаем данные
        showResults();
        calculatePlanning(data);
      });
    });
    
    function showResults() {
      document.getElementById('resultSection').classList.add('show');
      document.getElementById('loadingDiv').style.display = 'block';
      document.getElementById('resultsContent').style.display = 'none';
    }
    
    function calculatePlanning(data) {
      // Загружаем товары пользователя
      loadUserProducts(data);
    }
    
    function loadUserProducts(formData) {
      // Обновляем текст загрузки
      document.getElementById('loadingText').textContent = 'Загружаем товары пользователя...';
      
      // Получаем ID склада из скрытого select
      const warehouseId = document.getElementById('warehouse').value;
      console.log(`Загружаем остатки для склада ID: ${warehouseId}`);
      
      // Загружаем товары, остатки и заказы параллельно
      const dateFrom = formData.salesPeriodFrom;
      const dateTo = formData.salesPeriodTo;
      
      console.log(`Загружаем данные для периода: ${dateFrom} - ${dateTo}`);
      
      // Конвертируем даты из формата YYYY-MM-DD в DD.MM.YYYY для API
      function convertDateFormat(dateStr) {
        if (!dateStr) return dateStr;
        const parts = dateStr.split('-');
        if (parts.length === 3) {
          return `${parts[2]}.${parts[1]}.${parts[0]}`;
        }
        return dateStr;
      }
      
      const dateFromFormatted = convertDateFormat(dateFrom);
      const dateToFormatted = convertDateFormat(dateTo);
      
      console.log(`Конвертированные даты: ${dateFromFormatted} - ${dateToFormatted}`);
      
      Promise.all([
        fetch('/api/fbw/planning/products'),
        fetch(`/api/fbw/planning/stocks?warehouse_id=${warehouseId}`),
        fetch('/api/fbw/planning/stocks?warehouse_id=all'), // Остатки по всем складам
        fetch(`/api/fbw/planning/orders?warehouse_id=${warehouseId}&date_from=${dateFromFormatted}&date_to=${dateToFormatted}`)
      ])
      .then(responses => Promise.all(responses.map(r => r.json())))
      .then(([productsData, stocksData, allStocksData, ordersData]) => {
        console.log('Результаты загрузки:', {productsData, stocksData, allStocksData, ordersData});
        
        if (productsData.success && stocksData.success) {
          // Если остатки по всем складам не загрузились, используем пустые данные
          if (!allStocksData.success) {
            console.warn('Остатки по всем складам не загружены, используем пустые данные:', allStocksData);
            allStocksData = {
              success: true,
              stocks: {},
              total_stocks: 0,
              unique_products: 0
            };
          }
          
          // Если заказы не загрузились, используем пустые данные
          if (!ordersData.success) {
            console.warn('Заказы не загружены, используем пустые данные:', ordersData);
            ordersData = {
              success: true,
              orders: {},
              total_orders: 0,
              unique_products: 0,
              warehouse_name: stocksData.warehouse_name,
              date_from: dateFrom,
              date_to: dateTo
            };
          }
          console.log(`Загружено ${productsData.count} товаров с баркодами`);
          console.log(`Загружено остатков для склада ${stocksData.warehouse_id} (${stocksData.warehouse_name}):`, Object.keys(stocksData.stocks).length);
          console.log(`Загружено остатков по всем складам:`, Object.keys(allStocksData.stocks).length);
          console.log(`Загружено заказов для склада ${ordersData.warehouse_name} за период ${ordersData.date_from} - ${ordersData.date_to}:`, ordersData.total_orders);
          console.log('Остатки по выбранному складу:', stocksData.stocks);
          console.log('Остатки по всем складам:', allStocksData.stocks);
          console.log('Заказы:', ordersData.orders);
          
          // Показываем информацию об обновлении остатков
          if (stocksData.updated_at) {
            console.log(`Остатки обновлены: ${stocksData.updated_at}`);
            // Сохраняем время обновления для отображения пользователю
            window.stocksUpdatedAt = stocksData.updated_at;
          }
          
          // Отладка фото
          const productsWithPhotos = productsData.products.filter(p => p.photo);
          console.log(`Товаров с фото: ${productsWithPhotos.length}`);
          if (productsWithPhotos.length > 0) {
            console.log('Примеры товаров с фото:', productsWithPhotos.slice(0, 3).map(p => ({barcode: p.barcode, photo: p.photo})));
          }
          
          // Проверяем первые несколько товаров
          console.log('Первые 3 товара из API:', productsData.products.slice(0, 3).map(p => ({
            barcode: p.barcode, 
            name: p.name, 
            photo: p.photo,
            hasPhoto: !!p.photo
          })));
          
          // Проверим, есть ли остатки для товаров
          const productsWithStock = productsData.products.filter(p => stocksData.stocks[p.barcode] > 0);
          console.log(`Товаров с остатками: ${productsWithStock.length}`);
          if (productsWithStock.length > 0) {
            console.log('Примеры товаров с остатками:', productsWithStock.slice(0, 3));
          }
          
          // Проверим, есть ли заказы для товаров
          const productsWithOrders = productsData.products.filter(p => ordersData.orders[p.barcode] > 0);
          console.log(`Товаров с заказами: ${productsWithOrders.length}`);
          if (productsWithOrders.length > 0) {
            console.log('Примеры товаров с заказами:', productsWithOrders.slice(0, 3));
          }
          
          // Отладочная информация о сопоставлении баркодов
          console.log('Примеры баркодов товаров:', productsData.products.slice(0, 5).map(p => p.barcode));
          console.log('Примеры баркодов заказов:', Object.keys(ordersData.orders).slice(0, 5));
          
          // Проверим пересечение баркодов
          const productBarcodes = new Set(productsData.products.map(p => p.barcode));
          const orderBarcodes = new Set(Object.keys(ordersData.orders));
          const commonBarcodes = [...productBarcodes].filter(barcode => orderBarcodes.has(barcode));
          console.log(`Общих баркодов между товарами и заказами: ${commonBarcodes.length}`);
          if (commonBarcodes.length > 0) {
            console.log('Примеры общих баркодов:', commonBarcodes.slice(0, 5));
            
            // Проверим значения заказов для общих баркодов
            console.log('Значения заказов для общих баркодов:');
            commonBarcodes.slice(0, 5).forEach(barcode => {
              const orderQuantity = ordersData.orders[barcode];
              console.log(`  ${barcode}: ${orderQuantity} (тип: ${typeof orderQuantity})`);
            });
          }
          
          // Обновляем текст загрузки
          document.getElementById('loadingText').textContent = `Загружено ${productsData.count} товаров, остатков и ${ordersData.total_orders} заказов. Рассчитываем потребность...`;
          
          // Сохраняем общее количество заказов для отображения в сводке
          window.totalOrdersCount = ordersData.total_orders || 0;
          
          // Инициализируем данные для расчета
          const products = productsData.products.map(product => ({
            barcode: product.barcode,
            name: product.name,
            photo: product.photo,  // Добавляем поле photo
            currentStock: stocksData.stocks[product.barcode] || 0,  // Остаток на выбранном складе
            allStocks: allStocksData.stocks[product.barcode] || 0,  // Остаток по всем складам
            orderedInPeriod: ordersData.orders[product.barcode] || 0,  // Заказы за период
            salesPerDay: 0,
            requiredStock: 0,
            turnover: 0,
            toSupply: 0,
            inTransit: 0,
            nm_id: product.nm_id,
            supplier_article: product.supplier_article
          }));
          
          // Добавляем название склада в данные формы
          formData.warehouse_name = stocksData.warehouse_name;
          
          // Отладка: проверяем, что фото передались в массив products
          const productsWithPhotosAfter = products.filter(p => p.photo);
          console.log(`Товаров с фото после обработки: ${productsWithPhotosAfter.length}`);
          if (productsWithPhotosAfter.length > 0) {
            console.log('Примеры обработанных товаров с фото:', productsWithPhotosAfter.slice(0, 3).map(p => ({
              barcode: p.barcode, 
              photo: p.photo,
              hasPhoto: !!p.photo
            })));
          }
          
          // Сохраняем данные формы для использования в модальном окне
          window.lastFormData = formData;
          
          // Инициализируем глобальную переменную currentProducts
          currentProducts = [...products];
          console.log('Инициализирован currentProducts:', currentProducts.length);
          
          // Проверяем наличие непринятых поставок
          console.log(`Проверяем поставки для склада: "${stocksData.warehouse_name}"`);
          console.log('Товары перед проверкой поставок:', products.length);
          console.log('Примеры товаров перед проверкой поставок:', products.slice(0, 3));
          checkPendingSupplies(stocksData.warehouse_name, products, formData);
        } else {
          const errorMsg = productsData.message || stocksData.message || 'Ошибка загрузки данных';
          showError(errorMsg);
        }
      })
      .catch(error => {
        console.error('Ошибка загрузки данных:', error);
        showError('Ошибка загрузки данных: ' + error.message);
      });
    }
    
    function showResultsWithProducts(products, formData) {
      console.log('showResultsWithProducts вызвана с товарами:', products.length);
      console.log('Примеры товаров:', products.slice(0, 3));
      
      document.getElementById('loadingDiv').style.display = 'none';
      document.getElementById('resultsContent').style.display = 'block';
      
      // Активируем кнопку Excel
      document.getElementById('exportExcelBtn').disabled = false;
      
      // Показываем количество товаров и остатков
      const productsCountDiv = document.getElementById('productsCount');
      productsCountDiv.style.display = 'none';
      
      // Подсчитываем товары с остатками
      const productsWithStock = products.filter(p => p.currentStock > 0).length;
      const totalStock = products.reduce((sum, p) => sum + p.currentStock, 0);
      
      // Получаем название склада из API ответа
      const warehouseName = formData.warehouse_name || `Склад ${formData.warehouse}`;
      
      const totalOrders = window.totalOrdersCount || 0;
      const stocksUpdateTime = window.stocksUpdatedAt || '';
      productsCountDiv.innerHTML = `
        <div class="mb-2">
          <strong>Склад:</strong> ${warehouseName} | 
          <strong>Товаров:</strong> ${products.length} | 
          <strong>С остатками:</strong> ${productsWithStock} | 
          <strong>Общий остаток:</strong> ${totalStock} шт. | 
          <strong>Заказано за период:</strong> ${totalOrders} шт.
        </div>
        ${stocksUpdateTime ? `<div class="mb-2 text-success small"><i class="bi bi-arrow-clockwise"></i> Остатки обновлены: ${stocksUpdateTime}</div>` : ''}
      `;
      
      // Рассчитываем формулы для всех товаров
      const daysInPeriod = calculateDaysBetween(formData.salesPeriodFrom, formData.salesPeriodTo);
      const daysToSupply = calculateDaysBetween(new Date().toISOString().split('T')[0], formData.supplyDate);
      const planningDays = parseInt(formData.planningDays);
      
      products.forEach(item => {
        // Продаж в день = заказано за период / количество дней периода
        item.salesPerDay = daysInPeriod > 0 ? (item.orderedInPeriod / daysInPeriod) : 0;
        
        // Необходимый остаток = продаж в день * (дни планирования + дни до поставки)
        item.requiredStock = item.salesPerDay * (planningDays + daysToSupply);
        
        // Оборачиваемость = текущий остаток / продаж в день
        item.turnover = item.salesPerDay > 0 ? (item.currentStock / item.salesPerDay) : 0;
        
        // Поставить на склад = необходимый остаток - текущий остаток - в пути
        item.toSupply = Math.max(0, item.requiredStock - item.currentStock - item.inTransit);
      });
      
      renderResultsTable(products);
    }
    
    function showError(message) {
      document.getElementById('loadingDiv').style.display = 'none';
      document.getElementById('resultsContent').style.display = 'block';
      
      const tbody = document.getElementById('resultsTableBody');
      tbody.innerHTML = `
        <tr>
          <td colspan="10" class="text-center text-danger">
            <div class="py-4">
              <i class="bi bi-exclamation-triangle me-2"></i>
              ${message}
            </div>
          </td>
        </tr>
      `;
    }
    
    function calculateDaysBetween(dateFrom, dateTo) {
      const from = new Date(dateFrom);
      const to = new Date(dateTo);
      const diffTime = Math.abs(to - from);
      return Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // +1 чтобы включить оба дня
    }
    
    function renderResultsTable(data) {
      console.log('renderResultsTable вызвана с данными:', data.length);
      console.log('Примеры данных для рендеринга:', data.slice(0, 3));
      
      // Сохраняем данные для сортировки
      currentProducts = [...data];
      
      const tbody = document.getElementById('resultsTableBody');
      tbody.innerHTML = '';
      
      data.forEach((item, index) => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td class="numeric-column">${index + 1}</td>
          <td class="barcode-column">${item.barcode}</td>
          <td class="photo-column">
            ${item.photo ? 
              `<img src="${item.photo}" data-src="${item.photo}" class="product-thumb" alt="photo" style="width:45px;height:65px;object-fit:cover;cursor: zoom-in;" />` : 
              '<span class="text-muted">нет фото</span>'
            }
          </td>
          <td class="product-name-column">
            <div class="product-name" title="${item.name}">${item.name}</div>
          </td>
          <td class="numeric-column">${item.currentStock}</td>
          <td class="numeric-column">${item.allStocks}</td>
          <td class="numeric-column">${item.inTransit}</td>
          <td class="numeric-column">${item.orderedInPeriod}</td>
          <td class="numeric-column">${item.salesPerDay.toFixed(2)}</td>
          <td class="numeric-column">${Math.round(item.requiredStock)}</td>
          <td class="numeric-column">${item.turnover.toFixed(1)}</td>
          <td class="editable-cell">
            <input type="number" 
                   class="form-control form-control-sm" 
                   value="${Math.round(item.toSupply)}" 
                   min="0" 
                   data-index="${index}"
                   data-field="toSupply">
          </td>
        `;
        tbody.appendChild(row);
      });
      
      // Добавляем обработчики для редактируемых ячеек
      addEditableCellHandlers();
      
      // Применяем стили фона для всех input полей
      applyInputBackgrounds();
      
      // Обновляем итоги
      updateTotals();
      
      // Добавляем обработчик сортировки
      setupSorting();
    }
    
    function setupSorting() {
      // Обработчики для всех кнопок сортировки
      const sortButtons = document.querySelectorAll('.sort-btn');
      sortButtons.forEach(button => {
        button.addEventListener('click', function() {
          const column = this.getAttribute('data-column');
          sortTable(column);
        });
      });
    }
    
    function sortTable(column) {
      if (currentProducts.length === 0) return;
      
      // Определяем направление сортировки для данной колонки
      const sortKey = `sort_${column}`;
      if (!window[sortKey]) {
        window[sortKey] = 'desc'; // По умолчанию сортируем по убыванию
      }
      
      // Меняем направление сортировки для данной колонки
      window[sortKey] = window[sortKey] === 'asc' ? 'desc' : 'asc';
      const currentDirection = window[sortKey];
      
      // Сортируем данные
      const sortedProducts = [...currentProducts].sort((a, b) => {
        let aValue, bValue;
        
        // Получаем значения в зависимости от колонки
        switch(column) {
          case 'currentStock':
            aValue = parseInt(a.currentStock) || 0;
            bValue = parseInt(b.currentStock) || 0;
            break;
          case 'allStocks':
            aValue = parseInt(a.allStocks) || 0;
            bValue = parseInt(b.allStocks) || 0;
            break;
          case 'inTransit':
            aValue = parseInt(a.inTransit) || 0;
            bValue = parseInt(b.inTransit) || 0;
            break;
          case 'orderedInPeriod':
            aValue = parseInt(a.orderedInPeriod) || 0;
            bValue = parseInt(b.orderedInPeriod) || 0;
            break;
          case 'salesPerDay':
            aValue = parseFloat(a.salesPerDay) || 0;
            bValue = parseFloat(b.salesPerDay) || 0;
            break;
          case 'requiredStock':
            aValue = parseInt(a.requiredStock) || 0;
            bValue = parseInt(b.requiredStock) || 0;
            break;
          case 'turnover':
            aValue = parseFloat(a.turnover) || 0;
            bValue = parseFloat(b.turnover) || 0;
            break;
          case 'toSupply':
            aValue = parseInt(a.toSupply) || 0;
            bValue = parseInt(b.toSupply) || 0;
            break;
          default:
            return 0;
        }
        
        if (currentDirection === 'asc') {
          return aValue - bValue;
        } else {
          return bValue - aValue;
        }
      });
      
      // Отладка: проверяем сортировку
      console.log(`Сортировка ${column} ${currentDirection}:`, sortedProducts.slice(0, 5).map(p => ({
        barcode: p.barcode,
        name: p.name,
        [column]: p[column]
      })));
      
      // Обновляем currentProducts отсортированными данными
      currentProducts = [...sortedProducts];
      
      // Обновляем иконки всех кнопок сортировки
      const sortButtons = document.querySelectorAll('.sort-btn');
      sortButtons.forEach(button => {
        const icon = button.querySelector('i');
        const buttonColumn = button.getAttribute('data-column');
        const buttonSortKey = `sort_${buttonColumn}`;
        const buttonDirection = window[buttonSortKey] || 'desc';
        
        if (buttonColumn === column) {
          // Активная кнопка - показываем направление
          if (buttonDirection === 'asc') {
            icon.className = 'bi bi-arrow-up';
          } else {
            icon.className = 'bi bi-arrow-down';
          }
        } else {
          // Неактивные кнопки - показываем нейтральную иконку
          icon.className = 'bi bi-arrow-down-up';
        }
      });
      
      // Перерисовываем таблицу
      renderTableFromData(sortedProducts);
    }
    
    function renderTableFromData(data) {
      const tbody = document.getElementById('resultsTableBody');
      tbody.innerHTML = '';
      
      data.forEach((item, index) => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td class="numeric-column">${index + 1}</td>
          <td class="barcode-column">${item.barcode}</td>
          <td class="photo-column">
            ${item.photo ? 
              `<img src="${item.photo}" data-src="${item.photo}" class="product-thumb" alt="photo" style="width:45px;height:65px;object-fit:cover;cursor: zoom-in;" />` : 
              '<span class="text-muted">нет фото</span>'
            }
          </td>
          <td class="product-name-column">
            <div class="product-name" title="${item.name}">${item.name}</div>
          </td>
          <td class="numeric-column">${item.currentStock}</td>
          <td class="numeric-column">${item.allStocks}</td>
          <td class="numeric-column">${item.inTransit}</td>
          <td class="numeric-column">${item.orderedInPeriod}</td>
          <td class="numeric-column">${item.salesPerDay.toFixed(2)}</td>
          <td class="numeric-column">${Math.round(item.requiredStock)}</td>
          <td class="numeric-column">${item.turnover.toFixed(1)}</td>
          <td class="editable-cell">
            <input type="number" 
                   class="form-control form-control-sm" 
                   value="${Math.round(item.toSupply)}" 
                   min="0" 
                   data-index="${index}"
                   data-field="toSupply">
          </td>
        `;
        tbody.appendChild(row);
      });
      
      // Добавляем обработчики для редактируемых ячеек
      addEditableCellHandlers();
      
      // Применяем стили фона для всех input полей
      applyInputBackgrounds();
      
      // Обновляем итоги
      updateTotals();
    }
    
    function updateTotals() {
      const rows = document.querySelectorAll('#resultsTableBody tr');
      let totalCurrentStock = 0;
      let totalAllStocks = 0;
      let totalInTransit = 0;
      let totalOrdered = 0;
      let totalToSupply = 0;
      
      rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        if (cells.length >= 12) { // Увеличиваем до 12 из-за новой колонки
          totalCurrentStock += parseInt(cells[4].textContent) || 0;
          totalAllStocks += parseInt(cells[5].textContent) || 0;
          totalInTransit += parseInt(cells[6].textContent) || 0;
          totalOrdered += parseInt(cells[7].textContent) || 0;
          
          // Для "Поставить на склад" берем значение из input
          const toSupplyInput = cells[11].querySelector('input'); // Увеличиваем индекс
          if (toSupplyInput) {
            totalToSupply += parseInt(toSupplyInput.value) || 0;
          }
        }
      });
      
      // Обновляем итоги в строке
      document.getElementById('totalCurrentStock').textContent = totalCurrentStock;
      document.getElementById('totalAllStocks').textContent = totalAllStocks;
      document.getElementById('totalInTransit').textContent = totalInTransit;
      document.getElementById('totalOrdered').textContent = totalOrdered;
      document.getElementById('totalToSupply').textContent = totalToSupply;
      
      // Также обновляем данные в currentProducts для синхронизации
      updateCurrentProductsFromTable();
    }
    
    function addEditableCellHandlers() {
      const editableCells = document.querySelectorAll('.editable-cell');
      editableCells.forEach(cell => {
        cell.addEventListener('change', function() {
          const index = this.dataset.index;
          const field = this.dataset.field;
          const value = parseInt(this.value) || 0;
          
          console.log(`Изменено поле ${field} для товара ${index}: ${value}`);
          
          // Обновляем стили фона
          updateInputBackground(this);
          
          // Пересчитываем итоги при изменении
          updateTotals();
        });
        
        // Также обновляем итоги при вводе (не только при потере фокуса)
        cell.addEventListener('input', function() {
          // Обновляем стили фона
          updateInputBackground(this);
          
          updateTotals();
        });
      });
    }
    
    function updateInputBackground(input) {
      const value = parseInt(input.value) || 0;
      if (value > 0) {
        input.classList.add('highlighted');
      } else {
        input.classList.remove('highlighted');
      }
    }
    
    function applyInputBackgrounds() {
      const inputs = document.querySelectorAll('.editable-cell input');
      inputs.forEach(input => {
        updateInputBackground(input);
      });
    }
    
    function recalculateToSupply(index) {
      const row = document.querySelector(`[data-index="${index}"]`).closest('tr');
      const cells = row.querySelectorAll('td');
      
      // Получаем значения из таблицы
      const currentStock = parseInt(cells[2].textContent) || 0;
      const requiredStock = parseInt(cells[5].textContent) || 0;
      const inTransit = parseInt(row.querySelector('[data-field="inTransit"]').value) || 0;
      
      // Пересчитываем "Поставить на склад"
      const toSupply = Math.max(0, requiredStock - currentStock - inTransit);
      
      // Обновляем значение в поле
      const toSupplyInput = row.querySelector('[data-field="toSupply"]');
      toSupplyInput.value = toSupply;
      
      console.log(`Пересчитано "Поставить на склад" для товара ${index}: ${toSupply}`);
    }
    
    // Функция загрузки списка складов
    async function loadWarehouses() {
      try {
        const response = await fetch('/api/fbw/warehouses');
        const data = await response.json();
        
        if (data.success) {
          console.log('Данные складов с сервера:', data);
          allWarehouses = data.warehouses;
          filteredWarehouses = [...allWarehouses];
          setupWarehouseSearch();
          console.log(`Загружено ${data.count} складов:`, allWarehouses);
        } else {
          console.error('Ошибка загрузки складов:', data.message);
          showError('Ошибка загрузки списка складов');
        }
      } catch (error) {
        console.error('Ошибка загрузки складов:', error);
        showError('Ошибка загрузки списка складов');
      }
    }
    
    // Настройка поиска складов
    function setupWarehouseSearch() {
      const searchInput = document.getElementById('warehouseSearch');
      const dropdown = document.getElementById('warehouseDropdown');
      const hiddenSelect = document.getElementById('warehouse');
      
      console.log('Настройка поиска складов:');
      console.log('searchInput:', searchInput);
      console.log('dropdown:', dropdown);
      console.log('hiddenSelect:', hiddenSelect);
      
      // Показываем все склады при фокусе
      searchInput.addEventListener('focus', function() {
        showWarehouseDropdown();
      });
      
      // Поиск при вводе
      searchInput.addEventListener('input', function() {
        const query = this.value.toLowerCase().trim();
        console.log(`Input event: query="${query}", lastSelectedValue="${searchInput.dataset.lastSelectedValue}"`);
        
        // Очищаем скрытый select только если пользователь вводит текст вручную
        // (не при программном обновлении поля)
        if (query !== searchInput.dataset.lastSelectedValue) {
          hiddenSelect.value = '';
          console.log('Очищен скрытый select - пользователь вводит текст вручную');
        }
        
        if (query.length === 0) {
          filteredWarehouses = [...allWarehouses];
        } else {
          filteredWarehouses = allWarehouses.filter(warehouse => 
            warehouse.name.toLowerCase().includes(query) ||
            (warehouse.city && warehouse.city.toLowerCase().includes(query)) ||
            (warehouse.address && warehouse.address.toLowerCase().includes(query))
          );
        }
        showWarehouseDropdown();
      });
      
      // Скрытие при клике вне элемента
      document.addEventListener('click', function(e) {
        if (!e.target.closest('#warehouseSearch') && !e.target.closest('#warehouseDropdown')) {
          dropdown.style.display = 'none';
        }
      });
      
      // Обработка выбора склада
      dropdown.addEventListener('click', function(e) {
        console.log('Клик по dropdown:', e.target);
        const item = e.target.closest('.warehouse-search-item');
        console.log('Найденный item:', item);
        
        if (item) {
          const warehouseId = item.dataset.warehouseId;
          const warehouseName = item.dataset.warehouseName;
          
          console.log(`Данные склада - ID: ${warehouseId}, Name: ${warehouseName}`);
          
          // Обновляем скрытый select
          hiddenSelect.innerHTML = '';
          const option = document.createElement('option');
          option.value = warehouseId;
          option.textContent = warehouseName;
          option.selected = true;
          hiddenSelect.appendChild(option);
          console.log(`Скрытый select после обновления: ${hiddenSelect.value}`);
          
          // Обновляем отображаемый текст
          searchInput.value = warehouseName;
          
          // Устанавливаем флаг, что это программное обновление
          searchInput.dataset.lastSelectedValue = warehouseName;
          
          // Скрываем dropdown
          dropdown.style.display = 'none';
          
          console.log(`Выбран склад: ${warehouseName} (ID: ${warehouseId})`);
          console.log(`Скрытый select value: ${hiddenSelect.value}`);
          console.log(`Поле поиска value: ${searchInput.value}`);
        }
      });
    }
    
    // Показать dropdown со складами
    function showWarehouseDropdown() {
      const dropdown = document.getElementById('warehouseDropdown');
      dropdown.innerHTML = '';
      
      if (filteredWarehouses.length === 0) {
        dropdown.innerHTML = '<div class="warehouse-search-item text-muted">Склады не найдены</div>';
      } else {
        filteredWarehouses.forEach(warehouse => {
          const item = document.createElement('div');
          item.className = 'warehouse-search-item';
          if (warehouse.is_sorting_center) {
            item.classList.add('warehouse-sorting-center');
          }
          
          item.dataset.warehouseId = warehouse.id;
          item.dataset.warehouseName = warehouse.name;
          
          item.innerHTML = `
            <div class="warehouse-name">${warehouse.name || 'Без названия'}</div>
            <div class="warehouse-details">
              ${warehouse.city ? warehouse.city : ''} 
              ${warehouse.is_sorting_center ? '• Сортировочный центр' : ''}
            </div>
          `;
          
          dropdown.appendChild(item);
        });
      }
      
      dropdown.style.display = 'block';
    }
    
    // Функция для обновления данных из таблицы
    function updateCurrentProductsFromTable() {
      const rows = document.querySelectorAll('#resultsTableBody tr');
      rows.forEach((row, index) => {
        const cells = row.querySelectorAll('td');
        if (cells.length >= 12 && currentProducts[index]) { // Увеличиваем до 12
          // Обновляем значение "Поставить на склад" из input
          const toSupplyInput = cells[11].querySelector('input'); // Увеличиваем индекс
          if (toSupplyInput) {
            currentProducts[index].toSupply = parseInt(toSupplyInput.value) || 0;
          }
        }
      });
    }
    
    // Функция экспорта в Excel
    function exportToExcel() {
      if (currentProducts.length === 0) {
        alert('Нет данных для экспорта');
        return;
      }
      
      // Обновляем данные из таблицы перед экспортом
      updateCurrentProductsFromTable();
      
      // Отладка: проверяем обновленные данные
      console.log('Данные для экспорта (первые 3 товара):', currentProducts.slice(0, 3).map(p => ({
        barcode: p.barcode,
        name: p.name,
        toSupply: p.toSupply
      })));
      
      // Создаем CSV данные
      let csvContent = '\uFEFF'; // BOM для правильной кодировки
      
      // Заголовки
      const headers = [
        '№',
        'Баркод',
        'Наименование',
        'Текущий остаток',
        'Остаток по всем складам',
        'В пути на склад',
        'Заказано за период',
        'Продаж в день',
        'Необходимый остаток',
        'Оборачиваемость',
        'Поставить на склад'
      ];
      
      csvContent += headers.join(';') + '\n';
      
      // Данные
      currentProducts.forEach((item, index) => {
        const row = [
          index + 1,
          item.barcode,
          `"${item.name}"`, // Обрамляем в кавычки для корректного отображения
          item.currentStock,
          item.allStocks,
          item.inTransit,
          item.orderedInPeriod,
          item.salesPerDay.toFixed(2),
          Math.round(item.requiredStock),
          item.turnover.toFixed(1),
          Math.round(item.toSupply)
        ];
        csvContent += row.join(';') + '\n';
      });
      
      // Создаем и скачиваем файл
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      
      // Генерируем имя файла с датой
      const now = new Date();
      const dateStr = now.toISOString().split('T')[0];
      link.setAttribute('download', `planning_${dateStr}.csv`);
      
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
    
    // Функция проверки непринятых поставок
    async function checkPendingSupplies(warehouseName, products, formData) {
      try {
        console.log(`Проверяем поставки для склада: "${warehouseName}" (тип: ${typeof warehouseName})`);
        console.log('Товары в checkPendingSupplies:', products.length);
        console.log('Примеры товаров в checkPendingSupplies:', products.slice(0, 3));
        const startTime = performance.now();
        
        const response = await fetch(`/api/fbw/planning/supplies?warehouse_name=${encodeURIComponent(warehouseName)}&force_refresh=true`);
        const data = await response.json();
        
        const endTime = performance.now();
        console.log(`Проверка поставок заняла: ${(endTime - startTime).toFixed(2)} мс`);
        
        console.log('Ответ API поставок:', data);
        
        if (data.success && data.supplies && data.supplies.length > 0) {
          console.log(`Найдено ${data.supplies.length} непринятых поставок:`, data.supplies);
          pendingSupplies = data.supplies;
          showPendingSuppliesModal(products, formData);
        } else {
          console.log('Непринятых поставок не найдено. Причина:', {
            success: data.success,
            supplies: data.supplies,
            count: data.count,
            error: data.error
          });
          console.log('Продолжаем без модального окна, показываем результаты...');
          // Продолжаем без модального окна
          setTimeout(() => {
            showResultsWithProducts(products, formData);
          }, 500);
        }
      } catch (error) {
        console.error('Ошибка проверки поставок:', error);
        // Продолжаем без модального окна
        setTimeout(() => {
          showResultsWithProducts(products, formData);
        }, 500);
      }
    }
    
    // Функция показа модального окна с поставками
    function showPendingSuppliesModal(products, formData) {
      console.log('showPendingSuppliesModal вызвана с товарами:', products.length);
      console.log('Примеры товаров в showPendingSuppliesModal:', products.slice(0, 3));
      
      const suppliesList = document.getElementById('pendingSuppliesList');
      suppliesList.innerHTML = '';
      
      if (pendingSupplies.length === 0) {
        suppliesList.innerHTML = '<p class="text-muted">Поставки не найдены</p>';
        return;
      }
      
      // Создаем таблицу с поставками
      const table = document.createElement('table');
      table.className = 'table table-sm table-striped';
      table.innerHTML = `
        <thead class="table-light">
          <tr>
            <th>№ поставки</th>
            <th>Направление</th>
            <th>Количество товара</th>
            <th>Плановая дата отгрузки</th>
          </tr>
        </thead>
        <tbody>
          ${pendingSupplies.map(supply => `
            <tr>
              <td><strong>${supply.supply_id}</strong></td>
              <td>${supply.warehouse}</td>
              <td class="text-center">${supply.total_goods} шт.</td>
              <td>${supply.planned_date}</td>
            </tr>
          `).join('')}
        </tbody>
      `;
      
      suppliesList.appendChild(table);
      
      // Показываем модальное окно
      pendingSuppliesModal.show();
    }
    
    // Функция принятия поставок (добавление в "В пути на склад")
    function acceptPendingSupplies() {
      console.log('Пользователь принял поставки, добавляем в "В пути на склад"');
      console.log('currentProducts в acceptPendingSupplies:', currentProducts.length);
      console.log('Примеры currentProducts в acceptPendingSupplies:', currentProducts.slice(0, 3));
      
      // Сначала обнуляем все значения "В пути на склад"
      currentProducts.forEach(product => {
        product.inTransit = 0;
      });
      
      // Создаем карту товаров по баркодам для быстрого поиска
      const productsByBarcode = {};
      currentProducts.forEach(product => {
        productsByBarcode[product.barcode] = product;
      });
      
      console.log('Карта товаров по баркодам:', Object.keys(productsByBarcode).length, 'товаров');
      console.log('Примеры баркодов в списке планирования:', Object.keys(productsByBarcode).slice(0, 5));
      
      // Обрабатываем каждую поставку
      let totalAdded = 0;
      pendingSupplies.forEach(supply => {
        console.log(`Обрабатываем поставку ${supply.supply_id} с ${supply.goods ? supply.goods.length : 0} товарами`);
        
        if (supply.goods && supply.goods.length > 0) {
          console.log('Примеры баркодов в поставке:', supply.goods.slice(0, 5).map(g => g.barcode));
          
          supply.goods.forEach(good => {
            const barcode = good.barcode;
            const quantity = good.quantity || 0;
            
            if (productsByBarcode[barcode]) {
              productsByBarcode[barcode].inTransit += quantity;
              totalAdded += quantity;
              console.log(`Добавлено в "В пути": ${barcode} - ${quantity} шт.`);
            } else {
              console.log(`Товар с баркодом ${barcode} не найден в списке планирования`);
            }
          });
        } else {
          console.log(`Поставка ${supply.supply_id} не содержит товаров`);
        }
      });
      
      console.log(`Всего добавлено в "В пути на склад": ${totalAdded} товаров`);
      
      showResultsWithProducts(currentProducts, window.lastFormData);
    }
    
    // Функция применения настроек колонок таблицы
    function applyTableColumnSettings() {
      console.log('Функция applyTableColumnSettings вызвана');
      
      const columnSettings = {
        'colNumber': 0,
        'colBarcode': 1,
        'colPhoto': 2,
        'colName': 3,
        'colCurrentStock': 4,
        'colAllStocks': 5,
        'colInTransit': 6,
        'colOrdered': 7,
        'colSalesPerDay': 8,
        'colRequiredStock': 9,
        'colTurnover': 10,
        'colToSupply': 11
      };
      
      // Получаем состояние чекбоксов
      const visibleColumns = {};
      Object.keys(columnSettings).forEach(columnId => {
        const checkbox = document.getElementById(columnId);
        const isChecked = checkbox ? checkbox.checked : true;
        visibleColumns[columnSettings[columnId]] = isChecked;
        console.log(`Колонка ${columnId} (индекс ${columnSettings[columnId]}): ${isChecked ? 'видима' : 'скрыта'}`);
      });
      
      // Проверяем, есть ли таблица
      const resultsTable = document.getElementById('resultsTable');
      if (!resultsTable) {
        console.log('Таблица resultsTable не найдена');
        return;
      }
      
      // Скрываем/показываем колонки в заголовке таблицы
      const headerCells = document.querySelectorAll('#resultsTable thead tr:first-child th');
      const totalsCells = document.querySelectorAll('#resultsTable thead tr:last-child th');
      
      console.log(`Найдено ячеек заголовка: ${headerCells.length}`);
      console.log(`Найдено ячеек итогов: ${totalsCells.length}`);
      
      headerCells.forEach((cell, index) => {
        if (visibleColumns[index] !== undefined) {
          const shouldShow = visibleColumns[index];
          cell.style.display = shouldShow ? '' : 'none';
          console.log(`Заголовок ${index}: ${shouldShow ? 'показан' : 'скрыт'}`);
        }
      });
      
      totalsCells.forEach((cell, index) => {
        if (visibleColumns[index] !== undefined) {
          const shouldShow = visibleColumns[index];
          cell.style.display = shouldShow ? '' : 'none';
          console.log(`Итоги ${index}: ${shouldShow ? 'показаны' : 'скрыты'}`);
        }
      });
      
      // Скрываем/показываем кнопки сортировки в зависимости от видимости колонок
      const sortButtons = document.querySelectorAll('.sort-btn');
      const columnToIndex = {
        'currentStock': 4,
        'allStocks': 5,
        'inTransit': 6,
        'orderedInPeriod': 7,
        'salesPerDay': 8,
        'requiredStock': 9,
        'turnover': 10,
        'toSupply': 11
      };
      
      sortButtons.forEach(button => {
        const column = button.getAttribute('data-column');
        const columnIndex = columnToIndex[column];
        if (columnIndex !== undefined && visibleColumns[columnIndex] !== undefined) {
          button.style.display = visibleColumns[columnIndex] ? '' : 'none';
        }
      });
      
      // Скрываем/показываем колонки в строках данных
      const dataRows = document.querySelectorAll('#resultsTable tbody tr');
      console.log(`Найдено строк данных: ${dataRows.length}`);
      
      dataRows.forEach((row, rowIndex) => {
        const cells = row.querySelectorAll('td');
        cells.forEach((cell, index) => {
          if (visibleColumns[index] !== undefined) {
            const shouldShow = visibleColumns[index];
            cell.style.display = shouldShow ? '' : 'none';
            if (rowIndex === 0) { // Логируем только для первой строки
              console.log(`Данные ${index}: ${shouldShow ? 'показаны' : 'скрыты'}`);
            }
          }
        });
      });
      
      console.log('Настройки колонок применены:', visibleColumns);
    }
  </script>
  {% include '_footer.html' %}
  
</body>
</html>
